import chalk from 'chalk';
import boxen from 'boxen';
import axios from 'axios';
import fs from 'fs';
import mkdirp from 'mkdirp';
import path from 'path';
import FormData from 'form-data';
import spinner from 'cli-spinner';
import clap from 'clap';
import { fileURLToPath, pathToFileURL } from 'url';
import https from 'https';

import { SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION } from 'constants';

const VERSION = "0.1.1";
const LUCY_URL_ENV_VAR = "LUCY_URL";
const LUCY_APIKEY_ENV_VAR = "LUCY_API_KEY";

function upload(args:string[],lucyUrl:string,lucyApiKey:string,lucyEnv:string) {
    if (args.length>2) {
        throw 'Invalid arguments to upload command';

    }
    let jsonPath = './bundle.json';
    let sourcePath = './dist/main.js';
    if (args.length>0) {
        sourcePath = args[0];
    } else {
        console.log(chalk.gray('Loading default source file',sourcePath));
    }
    if (args.length > 1) {
        jsonPath = args[1];
    } else {
        console.log(chalk.gray('Loading default bundle file',jsonPath));

    }

    let url = "";
    let apiKey = "";
    let targetFolderPath = path.dirname(jsonPath);
    let configFiles = ['.spaceworx.config','.lucyxp.config'];
    if (lucyEnv) {
        if (!fs.existsSync(lucyEnv)) {
            throw 'Unable to find Lucy Environment file: ' + lucyEnv;
        }
        configFiles = [lucyEnv];
    }

    for(let i=0;i<configFiles.length;i++) {
        let configPath = configFiles[i];
        if (!configFiles[i].startsWith('/')) {
            configPath = path.join(targetFolderPath,configFiles[i]);
        }

        if (fs.existsSync(configPath)) {
            console.log(chalk.gray(`Loading configuration from ${configPath}`));
            try {
                let contents = fs.readFileSync(configPath).toString();
                let configData = JSON.parse(contents);
                url = configData['url'];
                apiKey = configData['apiKey'];
                break;
            } catch(e) {
                console.log(chalk.red(`Unable to read ${configPath}:${e}`));
            }

        }
    }

    if (lucyUrl) {
        url = lucyUrl;
    }
    if (lucyApiKey) {
        apiKey = lucyApiKey;
    }


    if (!url) {
        throw 'No url specified';
    }
    if (!url.startsWith('http')) {
        throw 'Invalid server url:' + url;
    }
    if (!apiKey) {
        throw 'No api key specified';
    }
    if (!fs.existsSync(sourcePath)) {
        throw 'Unable to find source files at ' + sourcePath;
    }
    if (!fs.existsSync(jsonPath)) {
        throw 'Unable to find bundle.json at ' + jsonPath;
    }
    let code = '';
    let json = '';
    try {
        code = fs.readFileSync(sourcePath).toString();
    } catch(e) {
        throw 'Unable to read ' + sourcePath + ': ' + e;
    }

    try {
        json = fs.readFileSync(jsonPath).toString();
    } catch(e) {
        throw 'Unable to read ' + sourcePath + ': ' + e;
    }

    /* validate that bundle.json contains valid json */
    try {
        JSON.parse(json);
    } catch(e) {
        throw sourcePath + ' does not contain valid json: ' + e;
    }

    let formData = new FormData();
    formData.append('code',code);
    formData.append('json',json);
    let apiUrl = `${url}/api/UXP/RegisterBundle`;
    let loader = new spinner.Spinner({
        text:'Sending...',
        stream:process.stdout,
        onTick:function(msg) {
            this.clearLine(this.stream);
            this.stream.write(msg);
        },
        
    });
    console.log(chalk.gray(`Uploading to ☁ at ${apiUrl} using SC:***${apiKey.substring(apiKey.length-3)}`));
    loader.start();
    let headers = formData.getHeaders();
    headers['Authorization'] = `APIKEY ${apiKey || ''}`;
    axios({
        method: "POST",
        url:apiUrl,
        data: formData,
        headers,
        cancelToken: new axios.CancelToken(function executor(c) {
            // An executor function receives a cancel function as a parameter

        })
    }).then(res => {
        let data = res.data;
        loader.stop(true);
        console.log(chalk.green('👍Done. Server returned:'));
        console.log(data);
    }).catch(e => {
        loader.stop(true);
        console.log(chalk.red('🧐Got an invalid response from the server: '));

        let message = JSON.stringify(e);
        if (!!e && !!e.response && !!e.response.data) {
            message = e.response.data;
            if (typeof message == 'object') {
                message = JSON.stringify(message);
            }
        }
        console.log(chalk.red(message));
    });
}
function login(url:string,apiKey:string) {
    console.log('Logging in....');
}


function generateUUID():string { 
    var d = new Date().getTime();
    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = (d + Math.random()*16)%16 | 0;
        d = Math.floor(d/16);
        return (c=='x' ? r : (r&0x7|0x8)).toString(16);
    });
    return uuid;
}

function resolve(name:string) {
    let root = __dirname;
    return path.join(root,'..',name);

}
function capitalize(x:string) {
    return x.charAt(0).toUpperCase() + x.slice(1)
}
function normalizeID(name:string) {
    return name.replace(/[^0-9A-Za-z]/g,'_')
}
function normalizeName(name:string) {
    return capitalize(normalizeID(name));
}
var walk = function(dir:string, done:(err:any,results:string[])=>void) {
    var results:string[] = [];
    fs.readdir(dir, function (err, list) {
        if (err) return done(err,[]);
        var i = 0;
        (function next() {
            var file = list[i++];
            if (!file) return done(null, results);
            file = path.resolve(dir, file);
            fs.stat(file, function (err, stat) {
                if (stat && stat.isDirectory()) {
                    walk(file, function (err, res) {
                        results = results.concat(res);
                        next();
                    });
                } else {
                    results.push(file);
                    next();
                }
            });
        })();
    });
  };
function writePath(targetPath:string,content:string) {
    let targetDir = path.dirname(targetPath);
    if (!fs.existsSync(targetDir)) {
        mkdirp.sync(targetDir);
    }
    console.log(chalk.gray('Writing to'),chalk.gray(targetPath));
    fs.writeFileSync(targetPath,content);
}
function processTemplate(name:string, file:string, templatePath:string, env: string) {
    let content = fs.readFileSync(file).toString();
    content = content.replace(/__WIDGET__/g,normalizeID(name));
    content = content.replace(/__WIDGETNAME__/g,normalizeName(name));

    let guid = generateUUID();
    content = content.replace(/__GUID__/g, guid);

    // replace environment
    content = content.replace(/__ENV__/g, env);

    let filePath = file.substring(templatePath.length+1);
    writePath(path.join(name,filePath),content);
}
function downloadLatest(projectName: string, env: string, file: string) {
    let url = `https://uxp.s3.amazonaws.com/dist/${env}/client/${file}`;
    let targetFilePath = path.join(projectName, file);
    const f = fs.createWriteStream(targetFilePath);
    console.log(chalk.gray('Loading',url));
    const request = https.get(url, function (response) {
        response.pipe(f);
        console.log(chalk.gray('saved',targetFilePath));
    });

}
function createWidget(name:string, env: string,done:()=>void) {
    if (fs.existsSync(name)) {
        throw 'Folder ' + name + ' already exists. Please choose a different name';
    }
    
    let templatePath = resolve('template')
    walk(templatePath,(err,results)=>{
        if (err) {
            throw err;
        }
        for(var i in results) {
            processTemplate(name,results[i],templatePath, env);
        }
        downloadLatest(name,env,'uxp.d.ts');
        done();
    });
}
export function main() {
    try {

        let cmd = clap
        .command('uxp-cli')
        .description('UXP Command Line Tool')
        .version(VERSION)
        ;
        cmd.command('init <project>')
        .option('--env <env>', 'development environment', {default: "master"})
       .action((actionArgs:{options: any, args:string[]})=>{
           let args = actionArgs.args || [];
           let name = args[0];

           // options 
           let options = actionArgs.options;
           let env = options.env

           createWidget(name, env,()=>{
            let msg = 'Ready. Run the following to get started\n\n';
            msg += chalk.green('Setup:\n');
            msg += 'cd ' + name + '\n';
            msg += 'npm install\n';
            msg += '\n';
            msg += chalk.green('Development:\n');
            msg += 'npm run dev\n';
            console.log(boxen(msg,{padding:2}));
        });
       });
        cmd.command('upload [dist.js] [bundle.json]')
        .option('--lucy-url <url>')
        .option('--lucy-apikey <apikey>')
        .option('--lucy-env <envfile>')
        .action((actionArgs:{args:string[],options:any})=>{
            let args = actionArgs.args || [];
            let options = actionArgs.options || {};

            upload(
            args,
            options.lucyUrl,
            options.lucyApikey,
            options.lucyEnv
            );
        })
        ;
        cmd.run();
    } catch(e) {
        console.error(chalk.red(e));

    }
     
}
